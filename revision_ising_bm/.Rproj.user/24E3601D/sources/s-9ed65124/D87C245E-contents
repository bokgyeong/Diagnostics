rm(list=ls())
library(tidyverse)
library(gridExtra)
get_legend<-function(myggplot){
  tmp <- ggplot_gtable(ggplot_build(myggplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)
}

# ===================================================
# ACD and AIKS
# ===================================================
# tuning parameter of DMH
# Nin = c(1, 3, 5, 50, 100)
# Nin = c(1, 3, 5, 100)
# Nin = c(1, 3, 5)
Nin = c(1, 2)

# tuning parameters of LikEm
# LikEm with prior determined by particles
d = c(50)
N = c(1000, 2000)
# LikEm with the same prior as others
# d = c(100)
# N = c(5000, 10000)

thres = 0.15

### new ACD ----------------------------------------------
newACD = data.frame()
for(i in Nin){
  load(paste("simNewACDLiang", i, ".RData", sep = ""))
  df = data.frame(Algorithm = paste('DMH (m=', i, ')', sep = ''), ACD = acdLiang[,1], Knots = knots)
  newACD = rbind(newACD, df)
}
for(i in d){
  for(j in N){
    load(paste("simNewACDLikEmd", i, 'N', j, ".RData", sep = ""))
    # load(paste("simNewACDABCLikd", i, 'N', j, ".RData", sep = ""))
    df = data.frame(Algorithm = paste('LikEm (d=', i, ", L=", j, ")", sep = ''), ACD = acdLikEm[,1], Knots = knots)
    newACD = rbind(newACD, df)
  }
}
load('simNewACDMurray.RData')
df = data.frame(Algorithm = 'Exchange', ACD = acdMurray[,1], Knots = knots)
newACD = rbind(newACD, df)
load('simNewACDMoller.RData')
df = data.frame(Algorithm = 'AVM', ACD = acdMoller[,1], Knots = knots)
newACD = rbind(newACD, df)
load('simNewACDAtchade.RData')
df = data.frame(Algorithm = 'ALR', ACD = acdAtchade[,1], Knots = knots)
newACD = rbind(newACD, df)
# load('simNewACDAEX.RData')
load('simNewACDAEX2.RData')
df = data.frame(Algorithm = 'AEX', ACD = acdAEX[,1], Knots = knots)
newACD = rbind(newACD, df)
# load('simNewACDPrior.RData')
# df = data.frame(Algorithm = 'Prior', ACD = acdPrior[,1], Knots = knots)
# newACD = rbind(newACD, df)


### AIKS based on the parameter suppport ------------------------------
AIKS = data.frame()
for(i in Nin){
  load(paste("simAIKSL2Liang", i, ".RData", sep = ""))
  df = data.frame(Algorithm = paste('DMH (m=', i, ')', sep = ''), AIKS = aiksLiang, Knots = knots)
  AIKS = rbind(AIKS, df)
}
for(i in d){
  for(j in N){
    load(paste("simAIKSL2LikEmd", i, 'N', j, ".RData", sep = ""))
    # load(paste("simAIKSL2ABCLikd", i, 'N', j, ".RData", sep = ""))
    df = data.frame(Algorithm = paste('LikEm (d=', i, ", L=", j, ")", sep = ''), AIKS = aiksLikEm, Knots = knots)
    AIKS = rbind(AIKS, df)
  }
}
load('simAIKSL2Murray.RData')
df = data.frame(Algorithm = 'Exchange', AIKS = aiksMurray, Knots = knots)
AIKS = rbind(AIKS, df)
load('simAIKSL2Moller.RData')
df = data.frame(Algorithm = 'AVM', AIKS = aiksMoller, Knots = knots)
AIKS = rbind(AIKS, df)
load('simAIKSL2Atchade.RData')
df = data.frame(Algorithm = 'ALR', AIKS = aiksAtchade, Knots = knots)
AIKS = rbind(AIKS, df)
# load('simAIKSL2AEX.RData')
load('simAIKSL2AEX2.RData')
df = data.frame(Algorithm = 'AEX', AIKS = aiksAEX, Knots = knots)
AIKS = rbind(AIKS, df)




### Visualization ----------------------------------------------------
pnewACD = ggplot(newACD, aes(x = Knots, y = ACD)) +
  geom_line(aes(color = Algorithm)) +
  geom_hline(yintercept = thres, linetype = 2) +
  # coord_cartesian(ylim = c(0, NA)) +
  # coord_cartesian(ylim = c(0, max(newACD$ACD, newACDLik$ACD))) +
  labs(x = "Number of sample points, n", y = "ACD")

pAIKS = ggplot(AIKS, aes(x = Knots, y = AIKS)) +
  geom_line(aes(color = Algorithm)) +
  # coord_cartesian(ylim = c(0, NA)) +
  # coord_cartesian(ylim = c(0, max(AIKS$AIKS, AIKSLik$AIKS))) +
  labs(x = "Number of sample points, n", y = "AIKS") +
  theme(legend.position = 'none')


# save and remove the legend
leg = get_legend(pnewACD)
pnewACD = pnewACD + theme(legend.position="none")


# ===================================================
# posterior density plots
# ===================================================
sample = data.frame()
load('simLiang.RData')
m = c(1, 2)
for(i in m){
  k = which(Nin == i)
  df = data.frame(Algorithm = paste('DMH (m=', i, ")", sep=''), parameter = Liang[[k]])
  sample = rbind(sample, df)
}
load('simLikEm.RData')
d = c(50)
N = c(1000, 2000)
# load('simABCLik.RData')
# d = c(100)
# N = c(5000, 10000)
for(i in d){
  for(j in N){
    k = which(tun[,1] == i & tun[,2] == j)
    df = data.frame(Algorithm = paste('LikEm (d=', i, ", L=", j, ")", sep = ''), parameter = LikEm[[k]])
    sample = rbind(sample, df)
  }
}
load("simMurray.RData")
df = data.frame(Algorithm = "Exchange", parameter = Murray)
sample = rbind(sample, df)
load("simMoller.RData")
df = data.frame(Algorithm = "AVM", parameter = Moller)
sample = rbind(sample, df)
load("simAtchade.RData")
df = data.frame(Algorithm = "ALR", parameter = Atchade)
sample = rbind(sample, df)
# load("simAEX.RData")
load("simAEX2.RData")
df = data.frame(Algorithm = "AEX", parameter = AEX)
sample = rbind(sample, df)
# load("simPrior.RData")
# df = data.frame(Algorithm = "Prior", parameter = Prior)
# sample = rbind(sample, df)



### posterior density plot ----------------------------------
pTh = ggplot(sample, aes(x = parameter)) +
  geom_density(aes(color = Algorithm)) +
  # geom_vline(xintercept = 0.2, color = 1, linetype = 2) +
  # scale_y_continuous(trans = "log") +
  # coord_cartesian(ylim = c(0, 19)) +
  # coord_cartesian(xlim = range(sample$parameter)) +
  labs(x = expression(theta), y = 'Density') + 
  theme(legend.position = 'none')


# draw
grid.arrange(pnewACD, pAIKS, pTh, leg, ncol = 4, 
             widths = c(1, 1, 1, 0.4)) # 1100*300

grid.arrange(pnewACD, pAIKS, leg, ncol = 3, 
             widths = c(1, 1, 0.6)) # 800*300



# ===============================================
# MCSE and ACD
# ===============================================
library(batchmeans)
library(coda)

### sample size for each algorithm (MCSE < 0.0005)
n = 60000
sample  %>%
  group_by(Algorithm) %>%
  slice(1:n) %>%
  summarise(Mean = unlist(bm(parameter))[1], MCSE = unlist(bm(parameter))[2])

size = data.frame(Algorithm = unique(sample$Algorithm), size = c(40000, 35000, 15000, 15000, 30000, 60000, 15000, 35000))



### cutoff for tail probability
alpha = 0.05
n = size[size$Algorithm == 'AVM',2]
cutoff = sample %>% filter(Algorithm == 'AVM') %>% slice(1:n) %>% 
  summarise(cutoff = quantile(parameter, c(alpha/2, 1-alpha/2))) %>% round(3)


table1 = c()
algorithms = c('AVM', 'Exchange', 'AEX', 'ALR', 'DMH (m=1)', 'DMH (m=2)', 'LikEm (d=50, L=1000)', 'LikEm (d=50, L=2000)')
for(algo in algorithms){
  n = size[size$Algorithm == algo,2]
  res = sample  %>% 
    filter(Algorithm %in% algo) %>%
    group_by(Algorithm) %>% 
    slice(1:n) %>% 
    summarise(Mean = round(unlist(bm(parameter))[1], 2), HPDl = round(HPDinterval(as.mcmc(parameter))[1],2), HPDu = round(HPDinterval(as.mcmc(parameter))[2],2)) %>% 
    add_column(sample %>% filter(Algorithm == algo) %>% slice(1:n) %>% summarise(TP = sum(parameter < cutoff[1,] | parameter > cutoff[2,])/n)) %>% 
    add_column(newACD %>% filter(Algorithm == algo) %>% slice(which(Knots == n)) %>% dplyr::select('ACD')) %>% 
    add_column(AIKS %>% filter(Algorithm == algo) %>% slice(which(Knots == n)) %>% dplyr::select(-c('Algorithm')))
  res$ACD = round(res$ACD, 3)
  res$TP = round(res$TP, 2)
  table1 = rbind(table1, res)
}
table1




### computing time
load('simFLiang.RData')
round(timeLiang[1] * size[size$Algorithm == 'DMH (m=1)',2] / 100000, 2)
round(timeLiang[2] * size[size$Algorithm == 'DMH (m=2)',2] / 100000, 2)
round(timeLiang[3] * size[size$Algorithm == 'DMH (m=3)',2] / 100000, 2)
round(timeMoller * size[size$Algorithm == 'AVM',2]/100000, 2)
round(timeMurray * size[size$Algorithm == 'Exchange',2]/100000, 2)
round(timeAEX * size[size$Algorithm == 'AEX',2] / 100000 + timeFLiang, 2)
round(timeAtchade * size[size$Algorithm == 'ALR',2] / 100000 + timeLiang[2] * 20000/100000, 2)

tun
d = 50
N = c(1000, 2000)
for(i in d){
  for(j in N){
    print(round(timeLikEm[which(tun[,1] == i & tun[,2] == j)] * size[size$Algorithm == paste('LikEm (d=', i, ', L=', j, ')', sep = ''),2] / 100000, 2))
  }
}


round(timeLikEm[3] * sizeLik[1,3] / 100000, 2)
round(timeLikEm[4] * sizeLik[2,3] / 100000, 2)
round(timeLikEm[5] * sizeLik[3,3] / 100000, 2)
round(timeLikEm[6] * sizeLik[4,3] / 100000, 2)
round(timeLikEm[7] * sizeLik[5,3] / 100000, 2)
round(timeLikEm[8] * sizeLik[6,3] / 100000, 2)
