rm(list=ls())
library(fields)
library(lattice)
library(coda)
library(Rcpp)
library(RcppArmadillo)
library(xtable)
library(snow)
library(doParallel)
library(foreach)
Sys.setenv("PKG_CXXFLAGS"="-fopenmp")
Sys.setenv("PKG_LIBS"="-fopenmp")


### set up for paralellization
nprocs = 19
# mp_type = "MPI"
mp_type = "PSOCK"
cl = parallel::makeCluster(nprocs, type=mp_type)
doParallel::registerDoParallel(cl)


#========================================================================
# Call a dataset, saved images, and functions
#========================================================================
# load('simLikEm.RData')
# load('simABCLik.RData')
load('simABCLik2.RData')
source("RFtns.R")
sourceCpp("RcppFtns.cpp")


#========================================================================
# Approximate score and hessian
#========================================================================
k = 3

tuns = tun[k,]
LikEm = LikEm[[k]]
burn = 0
niter = 100000
LikEm = LikEm[(burn+1):niter]
th = unique(LikEm)
nth = length(th)


### MC approximation with samples from Gibbs sampler ---------------------------
N = 100000
burn = 10000
Sx = Energy(X)


ptm = proc.time()[3]
appx = foreach(i = 1:nth, .combine = rbind, .packages = "Rcpp", .noexport = c("Energe", "GibbStat")) %dopar% {
  source("RFtns.R")
  sourceCpp("RcppFtns.cpp")

  Sy = GibbStat(X, th[i], N+burn)[-(1:burn)]
  score = approxScore(Sx, Sy)
  HJmat = approxHJmat(Sx, Sy)
  c(score, HJmat)

}
timeappx = proc.time()[3] - ptm
# save(LikEm, th, nth, Sx, appx, timeappx, file = paste('simAppxLikEmd', tuns[1], 'N', tuns[2], '.RData', sep = ''))
save(LikEm, th, nth, Sx, appx, timeappx, file = paste('simAppxABCLikd', tuns[1], 'N', tuns[2], '.RData', sep = ''))

