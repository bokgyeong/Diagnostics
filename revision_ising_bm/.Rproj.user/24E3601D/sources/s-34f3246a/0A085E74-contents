rm(list=ls())
library(snow)
library(doParallel)
library(foreach)
library(Rcpp)
library(RcppArmadillo)
library(MASS)
Sys.setenv("PKG_CXXFLAGS"="-fopenmp")
Sys.setenv("PKG_LIBS"="-fopenmp")


### set up for parallelization
nprocs = 4
# mp_type = "MPI"
mp_type = "PSOCK"
cl = parallel::makeCluster(nprocs, type=mp_type)
doParallel::registerDoParallel(cl)

#======================================================================
# ACD
#======================================================================
# d = c(50, 100)
# N = c(5000, 10000)
d = 100
N = c(1000, 2000)
tun = cbind(rep(d, each = length(N)), rep(N, length(d)))

for(k in 1:nrow(tun)){
  tuns = tun[k,]
  
  ptm = proc.time()[3]
  # load(paste('simAppxLikEmd', tuns[1], 'N', tuns[2], '.RData', sep = ''))
  load(paste('simAppxABCLikd', tuns[1], 'N', tuns[2], '.RData', sep = ''))
  
  nth = nrow(appx)
  tn = sapply(1:nth, function(i) sum(th[i]==LikEm))
  repsam = rep(seq_len(nth), tn)
  
  Hmat = appx[repsam,2]
  Jmat = appx[repsam,3]
  g = -Hmat - Jmat
  
  niter = length(Hmat)
  knots = seq(1000, niter, by = 100)
  
  acdLikEm = foreach(n = knots, .combine = 'rbind') %dopar% {
    # # old (L-1 norm)
    # library(batchmeans)
    # Mn = bm(g[1:n])
    # sum(abs(Mn$est))
    
    # weighted sum of cosine and length ratio
    source('RFtns.R')
    sensitivity = mean(-Hmat[1:n])
    variability = mean(Jmat[1:n])
    ACD(sensitivity, variability)
    
  }
  timeacdLikEm = proc.time()[3] - ptm
  # save(acdLikEm, knots, timeacdLikEm, file = paste('simNewACDLikEmd', tuns[1], 'N', tuns[2], '.RData', sep = ''))
  save(acdLikEm, knots, timeacdLikEm, file = paste('simNewACDABCLikd', tuns[1], 'N', tuns[2], '.RData', sep = ''))
}
