{
    "collab_server" : "",
    "contents" : "rm(list=ls())\nlibrary(coda)\nlibrary(ergm)\nlibrary(Rcpp)\nlibrary(RcppArmadillo)\nlibrary(MASS)\nlibrary(snow)\nlibrary(doParallel)\nlibrary(foreach)\nSys.setenv(\"PKG_CXXFLAGS\"=\"-fopenmp\")\nSys.setenv(\"PKG_LIBS\"=\"-fopenmp\")\n\n\nset.seed(123)\n#======================================================================\n# Call data and functions\n#======================================================================\n# load(\"isingData020.RData\")\n# load(\"Moller020.RData\")\n# load(\"zMoller020Perf.RData\")\nload(\"zMoller020Perf_thin.RData\")\n\n\n#======================================================================\n# Approximate IKSD\n#======================================================================\nz2 = zMoller[,2]; rm(zMoller, timezMoller)\n\n\nc = 1\nbeta = -1/2\nregint = seq(1000, length(Moller), by = 100)\nidx = sapply(regint, function(i) which(Moller[i] == th))\n\n\n### set up for parallelization\nnprocs = 19\n# mp_type = \"MPI\"\nmp_type = \"PSOCK\"\ncl = parallel::makeCluster(nprocs, type=mp_type)\ndoParallel::registerDoParallel(cl)\n\n\n\n### compute approximate knots\n# Reflect the domain of the parameter space\nptm = proc.time()[3]\nknot = foreach::foreach(i = 1:nth, .combine = cbind) %dopar% {\n  k0 = rep(0, nth)\n  for(ip in 1:i){\n    bthi = Sx-z2[i]\n    bthip = Sx-z2[ip]\n    \n    temp = c^2 + (th[i] - th[ip])^2\n    temp2 = th[i]-th[ip]\n    kn = temp^beta\n    knthi = 2*beta*(temp^(beta-1))*temp2\n    knthip = -knthi\n    knthithip = -2*beta*(temp^(beta-2))*(2*(temp2^2)*(beta-1)+temp)\n    \n    w = th[i]*(th[i]-1)*th[ip]*(th[ip]-1)\n    wthi = th[ip]*(th[ip]-1)*(2*th[i]-1)\n    wthip = th[i]*(th[i]-1)*(2*th[ip]-1)\n    wthithip = (2*th[i]-1)*(2*th[ip]-1)\n    \n    kR = w*kn\n    kRthi = wthi*kn + w*knthi\n    kRthip = wthip*kn + w*knthip\n    kRthithip = wthithip*kn + wthip*knthi + wthi*knthip + w*knthithip\n    \n    k0[ip] = bthi*bthip*kR + bthi*kRthip + bthip*kRthi + kRthithip\n  }\n  k0\n}\ntimeknot = proc.time()[3] - ptm\n# save(timeknot, knot, file = \"knotMoller020Perf.RData\")\n\n\n\n### compute approximate IMQ KSD\n# load(\"knotMoller020Perf.RData\")\nptm = proc.time()[3]\naIKSDMoller = foreach::foreach(k = idx, .combine = 'c') %dopar% {\n  n = regint[which(idx == k)]\n  qn = sapply(1:k, function(i) sum(th[i]==Moller[1:n])/n)\n\n  w = 0\n  for(i in 1:(k-1)){\n    w = w + (qn[i]^2)*knot[i,i] + qn[i]*sum(knot[i,(i+1):k]*qn[(i+1):k])*2\n  }\n  w = w + (qn[k]^2)*knot[k,k]\n  sqrt(w)\n\n  # sqrt(t(qn) %*% knot[1:k, 1:k] %*% qn )[1,1]\n}\ntimeaIKSDMoller = proc.time()[3] - ptm\n# save(regint, timeknot, aIKSDMoller, timeaIKSDMoller, file = \"aiksdMoller020Perf.RData\")\nsave(regint, timeknot, aIKSDMoller, timeaIKSDMoller, file = \"aiksdMoller020Perf_thin.RData\")\n\n\n\n\n# qn = sapply(1:nth, function(i) sum(th[i]==Moller)/regint[length(idx)])\n# # w = 0\n# # for(i in 1:nth){\n# #   w = w + qn[i]*sum(knot[i,]*qn)\n# # }\n# \n# w = 0\n# for(i in 1:(nth-1)){\n#   w = w + (qn[i]^2)*knot[i,i] + qn[i]*sum(knot[i,(i+1):nth]*qn[(i+1):nth])*2\n# }\n# w = w + (qn[nth]^2)*knot[nth,nth]\n# aiksdMoller = sqrt(w)\n# save(aiksdMoller, file = \"aiksdMoller_test.RData\")\n\n\n\n# sqrt(t(qn) %*% knot[1:k, 1:k] %*% qn )[1,1]\n\n\n# par(mfrow=c(1,1))\n# plot(regint, aIKSDMoller, type = \"l\", ylim = c(0, max(aIKSDMoller)))\n# \n# load(\"~/work/approxStein/ising/sdMoller020Perf.RData\")\n# lines(regint, sdMoller, col = \"red\")\n\n\n\n# qn = table(Moller[,1])/nrow(Moller)\n# qn[1]\n# \n# qn[1]*sum(knot[1,]*qn)\n# qn[2]*sum(knot[2,]*qn)\n# qn[3]*sum(knot[3,]*qn)\n# \n# \n# w = 0\n# for(i in 1:nrow(knot)){\n#   w = w + qn[i]*sum(knot[i,]*qn)\n# }\n# w\n# \n# sqrt(w)\n# \n# sum(knot[2,])\n# \n# length(knot[1,])\n# length(qn)\n# \n# plot(density(Moller[,1]))\n\n\n# ptm = proc.time()[3]\n# knot = foreach(i = 1:nth, .combine = 'cbind') %:% \n#   foreach(ip=1:nth, .combine = 'c') %dopar% {\n#     bthi = Sx-z2[i]\n#     bthip = Sx-z2[ip]\n#     temp = c^2 + (th[i,1] - th[ip,1])^2\n#     temp2 = th[i,1]-th[ip,1]\n#     kn = temp^beta\n#     knthi = 2*beta*(temp^(beta-1))*temp2\n#     knthip = -knthi\n#     knthithip = -2*beta*(temp^(beta-2))*(2*(temp2^2)*(beta-1)+temp)\n#     \n#     bthi*bthip*kn + bthi*knthip + bthip*knthi + knthithip\n#   }\n# timeknot = proc.time()[3] - ptm\n# save(knot, timeknot, file = \"knotMoller020.RData\")\n# \n# \n# # compute approximate IMQ KSD\n# ptm = proc.time()[3]\n# aIKSDMoller = foreach(k = idx, .combine = 'c') %dopar% {\n#   j = which(idx == k)\n#   n = regint[j]\n#   qn = sapply(1:k, function(i) sum(Moller[1:n,1]==th[i,1])/n)\n#   sqrt(t(qn) %*% knot[1:k, 1:k] %*% qn)[1,1]\n# }\n# timeaIKSDMoller = proc.time()[3] - ptm\n# save(timeknot, aIKSDMoller, timeaIKSDMoller, file = \"ksdMoller020.RData\")\n\n",
    "created" : 1603167471265.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2407134468",
    "id" : "954F7905",
    "lastKnownWriteTime" : 1603200311,
    "last_content_update" : 1603200311713,
    "path" : "~/work/approxKSD/ising/ksdMoller.R",
    "project_path" : "ksdMoller.R",
    "properties" : {
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}