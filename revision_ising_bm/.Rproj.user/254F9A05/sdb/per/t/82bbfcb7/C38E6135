{
    "collab_server" : "",
    "contents" : "rm(list=ls())\nlibrary(coda)\nlibrary(ergm)\nlibrary(Rcpp)\nlibrary(RcppArmadillo)\nlibrary(MASS)\nlibrary(snow)\nlibrary(doParallel)\nlibrary(foreach)\nSys.setenv(\"PKG_CXXFLAGS\"=\"-fopenmp\")\nSys.setenv(\"PKG_LIBS\"=\"-fopenmp\")\n\n\nset.seed(123)\n#======================================================================\n# Call data and functions\n#======================================================================\nload(\"isingData020.RData\")\nload(\"Moller020.RData\")\nload(\"zMoller020Perf.RData\")\nz2 = zMoller[,2]; rm(zMoller, timezMoller)\n# source(\"RFtns.R\")\n# sourceCpp(\"RcppFtns.cpp\")\n\n\n\n#======================================================================\n# IMQ KSD\n#======================================================================\n### empirical distribution for the sample\nth = unique(Moller)\nnth = nrow(th)\n\n\n### compute approximate IMQ KSD\nN = 1000 # the number of simulated datasets used to approximate the score Sxistic\nc = 1\nbeta = -1/2\nregint = seq(1000, nrow(Moller), by = 100)\nidx = sapply(1:length(regint), function(i) which(Moller[regint,1][i] == th[,1]))\n\n\n\n# set up for parallelization\nnprocs = 19\n# mp_type = \"MPI\"\nmp_type = \"PSOCK\"\ncl = parallel::makeCluster(nprocs, type=mp_type)\ndoParallel::registerDoParallel(cl)\n\n\n# # compute approximate IMQ KSD\n# ptm = proc.time()[3]\n# ksdIn1 = foreach::foreach(k = 1:length(idx), .combine = rbind) %dopar% {\n#   w2 = 0\n#   for(i in 1:idx[k]){\n#     for(ip in 1:idx[k]){\n#       bthi = Sx-z2[i,]\n#       bthip = Sx-z2[ip,]\n#       temp = c^2 + sum((th[i,] - th[ip,])^2)\n#       temp2 = th[i,]-th[ip,]\n#       kn = temp^beta\n#       knthi = 2*beta*(temp^(beta-1))*temp2\n#       knthip = -knthi\n#       knthithip = -2*beta*(temp^(beta-2))*(2*temp2*(beta-1)+temp)\n#       \n#       k0 = bthi*bthip*kn + bthi*knthip + bthip*knthi + knthithip\n#       w2 = q[i]*k0*q[ip] + w2 # something wrong on q\n#     }\n#   }\n#   sqrt(w2)\n# }\n# timeksdIn1 = proc.time()[3] - ptm\n# save(ksdIn1, timeksdIn1, file = \"sim_ksdIn1Gibb100.RData\")\n\n\n\n\n# compute approximate knots\nptm = proc.time()[3]\nknot = foreach::foreach(i = 1:nth, .combine = cbind) %dopar% {\n  k0 = rep(0, nth)\n  for(ip in 1:nth){\n    bthi = Sx-z2[i]\n    bthip = Sx-z2[ip]\n    temp = c^2 + (th[i,] - th[ip,])^2\n    temp2 = th[i,]-th[ip,]\n    kn = temp^beta\n    knthi = 2*beta*(temp^(beta-1))*temp2\n    knthip = -knthi\n    knthithip = -2*beta*(temp^(beta-2))*(2*(temp2^2)*(beta-1)+temp)\n\n    k0[ip] = bthi*bthip*kn + bthi*knthip + bthip*knthi + knthithip\n  }\n  k0\n}\ntimeknot = proc.time()[3] - ptm\n\n\n\n# compute approximate IMQ KSD\nptm = proc.time()[3]\naKSDMoller = foreach::foreach(k = idx, .combine = 'c') %dopar% {\n  j = which(idx == k)\n  n = regint[j]\n  qn = sapply(1:k, function(i) sum(Moller[1:n,1]==th[i,1])/n)\n  w = sqrt(t(qn) %*% knot[1:k, 1:k] %*% qn )[1,1]\n  sqrt(w^2) # L2 norm\n}\ntimeaKSDMoller = proc.time()[3] - ptm\nsave(timeknot, aKSDMoller, timeaKSDMoller, file = \"ksdMoller020.RData\")\n\n\n# plot(regint, aKSDMoller, type = \"l\")\n\n\n# ptm = proc.time()[3]\n# aKSDMoller = matrix(0, length(regint), ncol = 2)\n# for(i in 1:nth){\n#   for(ip in 1:nth){\n#     bthi = Sx-z2[i,]\n#     bthip = Sx-z2[ip,]\n#     temp = c^2 + sum((th[i,] - th[ip,])^2)\n#     temp2 = th[i,]-th[ip,]\n#     kn = temp^beta\n#     knthi = 2*beta*(temp^(beta-1))*temp2\n#     knthip = -knthi\n#     knthithip = -2*beta*(temp^(beta-2))*(2*(temp2^2)*(beta-1)+temp)\n#     \n#     k0 = bthi*bthip*kn + bthi*knthip + bthip*knthi + knthithip\n#     \n#     for(l in 1:length(idx)){\n#       k = idx[l]\n#       if(i <= k && ip <= k){\n#         n = regint[l]\n#         qn = sapply(c(i, ip), function(m) sum(Liang[1:n,1]==th[m,1])/n)\n#         aKSDMoller[l,] = aKSDMoller[l,] + prod(qn)*k0\n#       }\n#     }\n#     \n#   }\n# }\n# timeaKSDMoller = proc.time()[3] - ptm\n# save(aKSDMoller, timeaKSDMoller, file = \"sim_ksdIn1long.RData\")\n\n\n\n\n\n# nidx = length(idx)\n# \n# ptm = proc.time()[3]\n# prew = foreach::foreach(ip = 1:nth, .combine = rbind) %dopar% {\n#   library(snow)\n#   library(doParallel)\n#   library(foreach)\n#   knot = foreach::foreach(ip = 1:nth, .combine = rbind) %dopar% {\n#     bthi = Sx-z2[i,]\n#     bthip = Sx-z2[ip,]\n#     temp = c^2 + sum((th[i,] - th[ip,])^2)\n#     temp2 = th[i,]-th[ip,]\n#     kn = temp^beta\n#     knthi = 2*beta*(temp^(beta-1))*temp2\n#     knthip = -knthi\n#     knthithip = -2*beta*(temp^(beta-2))*(2*(temp2^2)*(beta-1)+temp)\n#     \n#     bthi*bthip*kn + bthi*knthip + bthip*knthi + knthithip\n#   }\n#   \n#   prew = foreach::foreach(l = (sum(i > regint)+1):nidx, .combine = 'c') %dopar% {\n#     k = idx[l]\n#     n = regint[l]\n#     qn = sapply(1:k, function(m) sum(Liang[1:n,1]==th[m,1])/n)\n#     (t(qn)%*%knot[1:k,])*qn[i]\n#   }\n#   \n#   c(rep(0, 2*nidx-length(prew)), prew)\n# }\n# timeprew = proc.time()[3] - ptm\n# \n# \n# w = colSums(prew) # n x (2*nidx)\n# \n# \n# ptm = proc.time()[3]\n# aKSDMoller = foreach::foreach(k = 1:nidx, .combine = 'c') %dopar% {\n#   sqrt(sum((w[,(2*k-1):(2*k)])^2)) # L2 norm\n# }\n# timeaKSDMoller = proc.time()[3] - ptm\n# \n# save(timeprew, aKSDMoller, timeaKSDMoller, file = \"sim_ksdIn1long.RData\")\n",
    "created" : 1600875588090.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3635678164",
    "id" : "C38E6135",
    "lastKnownWriteTime" : 1600875576,
    "last_content_update" : 1600875576,
    "path" : "~/work/approxKSD/ising/ksdMoller.R",
    "project_path" : "ksdMoller.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}