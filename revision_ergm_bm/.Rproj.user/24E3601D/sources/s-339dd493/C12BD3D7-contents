rm(list=ls())
library(fields)
library(coda)
library(ergm)
library(Rcpp)
library(RcppArmadillo)
library(MASS)
library(snow)
library(doParallel)
library(foreach)
Sys.setenv("PKG_CXXFLAGS"="-fopenmp")
Sys.setenv("PKG_LIBS"="-fopenmp")


# # set up foreach
# nprocs = 19
# # mp_type = "MPI"
# mp_type = "PSOCK"
# cl = parallel::makeCluster(nprocs, type=mp_type)
# doParallel::registerDoParallel(cl)


#======================================================================
# call data and functions
#======================================================================
load("simData.RData")
# load("sim2Data.RData")
sourceCpp("RcppFtns.cpp")


#======================================================================
# AEX
#======================================================================
### step 1. Conduct Liang's Fractional DMH to get auxiliary parameters -------
# AEX
d = 200                         # number of auxiliary parameters
N1 = 5500

# # AEX2
# d = 400
# N1 = 30000

aux.par = matrix(0,d,2)

formula = data ~ edges + gwesp(0.25,fixed=TRUE)
m = ergm(formula, estimate="MPLE")

ptm = proc.time()[3]
FLiang = ergmFDMH(X, diag(0.0025,2), matrix(m$coef,1), N1, 10)  # multiply 0.5 in c code
timeFLiang = proc.time()[3] - ptm 
save(FLiang, timeFLiang, file = "simFLiang.RData")
# save(FLiang, timeFLiang, file = "simFLiang2.RData")


FLiang = FLiang[-(1:500),]      # burn in 500
stand = matrix(0,nrow(FLiang),2)        # standardized   
for(i in 1:2){ stand[,i] = (FLiang[,i]-min(FLiang[,i]))/(max(FLiang[,i])-min(FLiang[,i])) }
stand = cbind( unique(stand[,1]), unique(stand[,2]) )
dmat = rdist(stand)             # distance matrix

# choose auxiliary parameters through min max procedure
ind = 1; A = 1; Ac = 2:dim(stand)[1]
aux.par[1,] = stand[ind,]

ind = which.max( dmat[,A] )
A = c(A,ind)
Ac = Ac[-which(Ac==ind)]
aux.par[2,] = stand[ind,]


for(i in 3:d){
  dummy = max( apply( dmat[,A] , 1, min )[Ac] )
  ind = which(dmat[,A] == dummy, arr.ind = T)[1]
  A = c(A,ind)
  Ac = Ac[-which(Ac==ind)]
  aux.par[i,] = stand[ind,]
}

dist.aux.par = rdist(aux.par) # distance matrix for aux.par (for standardized version)
for(i in 1:2){ aux.par[,i] = (max(FLiang[,i])-min(FLiang[,i]))*aux.par[,i] + min(FLiang[,i]) }  



### step 2. Run AEX --------------------------- 
Niter = 100000
cycle = 1
COV = cov(aux.par)

# AEX, AEX2
Numaux = 30000
t0 = 20000
neighbor = 20



ptm = proc.time()[3]
res = ergmAEX(Niter, Numaux, cycle, t0, neighbor, aux.par, dist.aux.par, matrix(m$coef,1), COV, X)
timeAEX = proc.time()[3] - ptm
AEX = res$par

save(X, stat, AEX, timeAEX, file = "simAEX.RData")
# save(X, stat, AEX, timeAEX, file = "simAEX2.RData")


