{
    "collab_server" : "",
    "contents" : "// -*- mode: C++; c-indent-level: 4; c-basic-offset: 4; indent-tabs-mode: nil; -*-\n\n\n// we only include RcppArmadillo.h which pulls Rcpp.h in for us\n// [[Rcpp::depends(\"RcppArmadillo\")]]\n\n\n#include <RcppArmadillo.h>\n#include <limits>\n#include <omp.h>\n#define min(x,y) (((x) < (y)) ? (x) : (y))\n\nusing namespace std;\nusing namespace Rcpp;\nusing namespace arma;\n\n\n\n\n// [[Rcpp::export]]\ndouble Choose(int x, int y){\n  double result1 = 1, result2 = 1, result;\n  int iter = y;\n  \n  if( x< y ){ result = 0;\t}else{\t\n    for(int i = 0; i<iter; i++){\n      result1 = result1*x;\n      result2 = result2*y;\n      y = y-1;\n      x = x-1;   \t\n    }\t\n    \n    \n    result = result1/result2;\n  }\n  return(result);\n}\n\n\n\n// [[Rcpp::export]]\nvec countShared(vec rowsum, mat X){\n  \n  int numedges = sum(rowsum)/2, nrow = rowsum.n_elem ,ind;\n  vec hist = zeros(numedges);\n  int num = 0;\n  for(int k = 0; k< nrow; k++){\n    for(int j = 0; j< (k+1); j++){ \n      if( X(k,j) == 1){  for(int i = 0; i<nrow; i++){ hist(num) =  hist(num) + X(i,k)*X(k,j)*X(j,i); }\n      num = num + 1; }\n      \n    }\n  }\n  vec shared = zeros(nrow);\n  for(int i = 0; i < numedges; i++ ){\n    ind = hist(i);\t\n    if(ind>0){ shared(ind-1) = shared(ind-1) + 1; }\n  }\n  return(shared);\n}\n\n\n\n// [[Rcpp::export]]\nvec Summary(mat X){\n  int nrow = X.n_rows;\n  double decay = 0.25;\n  vec rowsum = sum(X,1), result = zeros(2);\n  \n  \n  vec shared = countShared(rowsum,X);\n  \n  \n  for(int i = 0; i< nrow; i++){\n    result(0) = result(0) + Choose(rowsum(i),1);\n    result(1) = result(1) + (   1- pow( (1-exp(-decay)),i+1)  )*shared(i);   \n  }\n  \n  result(0)=result(0)/2;\n  result(1)=exp(decay)*result(1);   \n  \n  return result;\n}\n\n\n\n// [[Rcpp::export]]\nvec Gibbs(mat X, vec coef, int cycle){\n  int nrow = X.n_rows,indi,indj,prei,prej,res;\n  double decay = 0.25;\n  vec star = sum(X,1), changestat = zeros(2), Sumstat = Summary(X) ;\n  rowvec ivec = trans( zeros(nrow) ), jvec = trans( zeros(nrow) );\n  vec geoweight = zeros(nrow);\n  for(int i =0; i<nrow; i++){ geoweight(i) = 1- pow( (1-exp(-decay)),i+1); }\n  \n  \n  for(int l = 0; l< cycle; l++){\n    for(int i = 1; i< nrow; i++){\n      for(int j = 0; j< i; j++){\n        ivec(i) = 1; jvec(j) = 1;\n        res = 0; \n        \n        \n        if(X(i,j)==0){  \n          indi = star(i) + 1, indj = star(j) + 1; \n          \n          changestat(0) = ( Choose(indi,1) + Choose(indj,1) - Choose(star(i),1) - Choose(star(j),1) )/2;\n          \n          \n          changestat(1) = 0;     \n          for(int k = 0; k< nrow; k++){\n            if(   ( X(i,k) == 1 ) & ( X(j,k) == 1  )   ){\n              prei = sum( X.row(i)%X.row(k) );\n              prej = sum( X.row(j)%X.row(k) );\n              \n              changestat(1) = changestat(1) + exp(decay)*geoweight(prei+1-1) ; \n              if(prei >0){ changestat(1) = changestat(1) - exp(decay)*geoweight(prei-1);} \n              changestat(1) = changestat(1) + exp(decay)*geoweight(prej+1-1) ; \n              if(prej >0){ changestat(1) = changestat(1) - exp(decay)*geoweight(prej-1);} \n              res = res + 1; \n            }\n          }\n          if(res > 0){ changestat(1) = changestat(1) + exp(decay)*geoweight(res-1); }\n          \n          \n          vec r =  exp(trans(coef)*changestat) ;         \n          double p = r(0)/(1+r(0));   \t\t   \n          if( randu() < p  ){\n            X(i,j) = X(j,i) = 1; \n            star(i) = indi; star(j) = indj;\t\t \n            Sumstat = Sumstat + changestat;\n          }\n          \n          \n        }else{\n          indi = star(i) - 1, indj = star(j) - 1;\t\n          \n          changestat(0) = ( Choose(star(i),1) + Choose(star(j),1) - Choose(indi,1) - Choose(indj,1) )/2;\n          \n          \n          changestat(1) = 0;\n          for(int k = 0; k< nrow; k++){\n            if(   ( X(i,k) == 1 ) & ( X(j,k) == 1  )   ){\n              prei = sum( X.row(i)%X.row(k) );\n              prej = sum( X.row(j)%X.row(k) );\n              if(prei-1 >0){changestat(1) = changestat(1) - exp(decay)*geoweight(prei-1-1); } \n              changestat(1) = changestat(1) + exp(decay)*geoweight(prei-1); \n              if(prej-1 >0){changestat(1) = changestat(1) - exp(decay)*geoweight(prej-1-1); } \n              changestat(1) = changestat(1) + exp(decay)*geoweight(prej-1); \n              res = res + 1; \n            }\n          }\n          if(res > 0){ changestat(1) = changestat(1) + exp(decay)*geoweight(res-1); }\n          \n          \n          vec r =  exp(trans(coef)*changestat) ;         \n          double p = r(0)/(1+r(0));   \t\t   \n          if( randu() > p  ){\n            X(i,j) = X(j,i) = 0; \n            star(i) = indi; star(j) = indj;  \n            Sumstat = Sumstat - changestat;\n          }             \n        }\n        \n        ivec(i) = 0; jvec(j) = 0;\n      }\n    }   \n  }\n  \n  return(Sumstat); \n}\n\n\n// [[Rcpp::export]]\nmat Gibbs2(mat X, vec coef, int cycle){\n  int nrow = X.n_rows,indi,indj,prei,prej,res;\n  double decay = 0.25;\n  vec star = sum(X,1), changestat = zeros(2), Sumstat = Summary(X) ;\n  rowvec ivec = trans( zeros(nrow) ), jvec = trans( zeros(nrow) );\n  vec geoweight = zeros(nrow);\n  for(int i =0; i<nrow; i++){ geoweight(i) = 1- pow( (1-exp(-decay)),i+1); }\n  \n  \n  for(int l = 0; l< cycle; l++){\n    for(int i = 1; i< nrow; i++){\n      for(int j = 0; j< i; j++){\n        ivec(i) = 1; jvec(j) = 1;\n        res = 0; \n        \n        \n        if(X(i,j)==0){  \n          indi = star(i) + 1, indj = star(j) + 1; \n          \n          changestat(0) = ( Choose(indi,1) + Choose(indj,1) - Choose(star(i),1) - Choose(star(j),1) )/2;\n          \n          \n          changestat(1) = 0;     \n          for(int k = 0; k< nrow; k++){\n            if(   ( X(i,k) == 1 ) & ( X(j,k) == 1  )   ){\n              prei = sum( X.row(i)%X.row(k) );\n              prej = sum( X.row(j)%X.row(k) );\n              \n              changestat(1) = changestat(1) + exp(decay)*geoweight(prei+1-1) ; \n              if(prei >0){ changestat(1) = changestat(1) - exp(decay)*geoweight(prei-1);} \n              changestat(1) = changestat(1) + exp(decay)*geoweight(prej+1-1) ; \n              if(prej >0){ changestat(1) = changestat(1) - exp(decay)*geoweight(prej-1);} \n              res = res + 1; \n            }\n          }\n          if(res > 0){ changestat(1) = changestat(1) + exp(decay)*geoweight(res-1); }\n          \n          \n          vec r =  exp(trans(coef)*changestat) ;         \n          double p = r(0)/(1+r(0));   \t\t   \n          if( randu() < p  ){\n            X(i,j) = X(j,i) = 1; \n            star(i) = indi; star(j) = indj;\t\t \n            Sumstat = Sumstat + changestat;\n          }\n          \n          \n        }else{\n          indi = star(i) - 1, indj = star(j) - 1;\t\n          \n          changestat(0) = ( Choose(star(i),1) + Choose(star(j),1) - Choose(indi,1) - Choose(indj,1) )/2;\n          \n          \n          changestat(1) = 0;\n          for(int k = 0; k< nrow; k++){\n            if(   ( X(i,k) == 1 ) & ( X(j,k) == 1  )   ){\n              prei = sum( X.row(i)%X.row(k) );\n              prej = sum( X.row(j)%X.row(k) );\n              if(prei-1 >0){changestat(1) = changestat(1) - exp(decay)*geoweight(prei-1-1); } \n              changestat(1) = changestat(1) + exp(decay)*geoweight(prei-1); \n              if(prej-1 >0){changestat(1) = changestat(1) - exp(decay)*geoweight(prej-1-1); } \n              changestat(1) = changestat(1) + exp(decay)*geoweight(prej-1); \n              res = res + 1; \n            }\n          }\n          if(res > 0){ changestat(1) = changestat(1) + exp(decay)*geoweight(res-1); }\n          \n          \n          vec r =  exp(trans(coef)*changestat) ;         \n          double p = r(0)/(1+r(0));   \t\t   \n          if( randu() > p  ){\n            X(i,j) = X(j,i) = 0; \n            star(i) = indi; star(j) = indj;  \n            Sumstat = Sumstat - changestat;\n          }             \n        }\n        \n        ivec(i) = 0; jvec(j) = 0;\n      }\n    }   \n  }\n  \n  return(X); \n}\n\n\n// [[Rcpp::export]]\ncube pAuxSamp(mat X, int cycle, mat Designmat, int m, int num){\n  \n  int thnrow = Designmat.n_rows;            \n  cube H(thnrow,2,m);                       \n  omp_set_num_threads(num);\n  \n  \n  \n  for(int M = 0; M < m; M++){            \n    \n    int i;\n#pragma omp parallel shared(Designmat) private(i)\n{\t\n#pragma omp for schedule(static)  \n  for(i = 0; i < thnrow; i++){\n    vec thetaprop = trans( Designmat.row( i ) );        \n    vec sumstat = Gibbs(X, thetaprop, cycle);\n    \n    for(int j = 0; j < 2; j++){ H(i,j,M) = sumstat[j];  }\n    \n  }\n}\n  }\n  return(H);        \t\n}\n\n\n// [[Rcpp::export]]\nmat pResponseErgm(mat X, int cycle, vec hatparameter, int m, int num){\n  mat H(m,2);                       \n  omp_set_num_threads(num);\n  \n  int M;\n#pragma omp parallel shared(H) private(M)\n{\t\n#pragma omp for schedule(static)  \n  for(M = 0; M < m; M++){                           \n    vec sumstat = Gibbs(X, hatparameter, cycle);  \n    H(M,0) = sumstat[0];\n    H(M,1) = sumstat[1];\n  }\n}\nreturn(H);        \t\n}\n\n\n// [[Rcpp::export]]\nmat ergmDMH(mat X, mat COV, mat theta, int outer, int cycle){\n  \n  double logprob,u;                        \n  int nCOVcols = COV.n_cols;                \n  vec thetaprev(nCOVcols);                  \n  vec stat = Summary(X), statprop(nCOVcols); \n  \n  \n  for(int l = 0; l< outer; l++){\n    \n    if( (l > 1000) && (l <= 10000) ){ \n      COV = cov(theta);\n    }\t\n    \n    for(int i = 0; i< nCOVcols; i++){\n      thetaprev[i] = theta(l,i);\n    }\n    \n    vec Znormal = randn(nCOVcols);                                           \n    vec thetaprop = trans(  trans(thetaprev) + trans(Znormal)*chol(COV)  );  \n    \n    \n    statprop = Gibbs(X, thetaprop, cycle);\n    \n    \n    vec dummy = ( -0.05*trans(thetaprop)*thetaprop + 0.05*trans(thetaprev)*thetaprev + trans(thetaprev - thetaprop)*(statprop - stat) );\n    logprob = dummy[0];\n    u = log( randu() );\n    if( u< logprob ){\n      theta.insert_rows(l+1,trans(thetaprop));\n    }else{\n      theta.insert_rows(l+1,trans(thetaprev));\n    }\n    \n  }\n  \n  return(theta);\t\n}\n\n\n\n// // inner loops increased with the length of chain increased\n// // [[Rcpp::export]]\n// mat ergmDMH2(mat X, mat COV, mat theta, int outer){\n//   \n//   double logprob,u;\n//   int nCOVcols = COV.n_cols;\n//   vec thetaprev(nCOVcols);\n//   vec stat = Summary(X), statprop(nCOVcols);\n//   int cycle = 0;\n//   \n//   \n//   for(int l = 0; l< outer; l++){\n//     \n//     if( (l > 1000) && (l <= 10000) ){\n//       COV = cov(theta);\n//     }\n//     \n//     for(int i = 0; i< nCOVcols; i++){\n//       thetaprev[i] = theta(l,i);\n//     }\n//     \n//     vec Znormal = randn(nCOVcols);\n//     vec thetaprop = trans(  trans(thetaprev) + trans(Znormal)*chol(COV)  );\n//     \n//     cycle = ceil(2*sqrt(l+1));\n//     statprop = Gibbs(X, thetaprop, cycle);\n//     \n//     \n//     vec dummy = ( -0.05*trans(thetaprop)*thetaprop + 0.05*trans(thetaprev)*thetaprev + trans(thetaprev - thetaprop)*(statprop - stat) );\n//     logprob = dummy[0];\n//     u = log( randu() );\n//     if( u< logprob ){\n//       theta.insert_rows(l+1,trans(thetaprop));\n//     }else{\n//       theta.insert_rows(l+1,trans(thetaprev));\n//     }\n//     \n//   }\n//   \n//   return(theta);\n// }\n\n\n\n\n// // [[Rcpp::export]]\n// mat ergmFDMH(mat X, mat COV, mat theta, int outer, int cycle){\n//   \n//   double logprob,u;                        \n//   int nCOVcols = COV.n_cols;                \n//   vec thetaprev(nCOVcols);                  \n//   vec stat = Summary(X), statprop(nCOVcols); \n//   \n//   \n//   for(int l = 0; l< outer; l++){\n//     \n//     if( (l > 1000) && (l <= 10000) ){ \n//       COV = cov(theta);\n//     }\t\n//     \n//     for(int i = 0; i< nCOVcols; i++){\n//       thetaprev[i] = theta(l,i);\n//     }\n//     \n//     vec Znormal = randn(nCOVcols);                                           \n//     vec thetaprop = trans(  trans(thetaprev) + trans(Znormal)*chol(COV)  );  \n//     \n//     \n//     statprop = Gibbs(X, thetaprop, cycle);\n//     \n//     \n//     vec dummy = ( -0.05*trans(thetaprop)*thetaprop + 0.05*trans(thetaprev)*thetaprev + trans(thetaprev - thetaprop)*(statprop - stat) );\n//     logprob = dummy[0];\n//     logprob = 0.5 * logprob;\n//     u = log( randu() );\n//     if( u< logprob ){\n//       theta.insert_rows(l+1,trans(thetaprop));\n//     }else{\n//       theta.insert_rows(l+1,trans(thetaprev));\n//     }\n//     \n//   }\n//   \n//   return(theta);\t\n// }\n\n\n\n// [[Rcpp::export]]\nmat GPmcmcErgmLik(int Niter, mat theta, mat COV, double lhXZ, vec betahat, vec phihat, mat Designmat, vec y, vec stat){\n  int thnrow = Designmat.n_rows;                                                \n  int nCOVcols = COV.n_cols;                                                    \n  vec thetaprev(nCOVcols);                                                     \n  \n  double lhXZp = 0, logprob = 0, u = 0;                                               \n  double negativeInf = -std::numeric_limits<float>::infinity();;\t               \n  double phi1hat = phihat[0], phi2hat = phihat[1], sigmasqhat = phihat[2]; \n  \n  \n  int percentile = 0.0025*thnrow; \n  \n  \n  mat Domain(2,nCOVcols);                                                         \n  for(int i = 0; i < nCOVcols; i++){\n    vec dummy = sort( Designmat.col( i ) );\n    Domain(0,i) = dummy(percentile);\n    Domain(1,i) = dummy(thnrow-1-percentile);\n  }\n  \n  mat h1(thnrow,thnrow), h2(thnrow,thnrow);   \n  vec h1dcross(thnrow), h2dcross(thnrow);     \n  \n  for(int i = 0; i < thnrow; i++){\n    for(int j = 0; j <= i; j++){\n      h1(i,j) = h1(j,i) = fabs(Designmat(i,0)-Designmat(j,0));\n      h2(i,j) = h2(j,i) = fabs(Designmat(i,1)-Designmat(j,1));\n    }\n  }\n  mat Sigma = sigmasqhat*(1+sqrt(3)*h1/phi1hat)%exp(-sqrt(3)*h1/phi1hat)%(1+sqrt(3)*h2/phi2hat)%exp(-sqrt(3)*h2/phi2hat);\n  mat InvSigma = inv(Sigma);\t   \n  mat Xth = ones(thnrow,1);\n  Xth.insert_cols(1,Designmat);\t \n  \n  \n  \n  for(int k = 0; k< Niter; k++){\n    if( (k > 1000) && (k <= 10000) ){ \n      COV = cov(theta);\n    }\t\n    vec Znormal = randn(nCOVcols);\n    for(int i = 0; i< nCOVcols; i++){\n      thetaprev[i] = theta(k,i);\n    }\n    \n    \n    vec thetaprop = trans(  trans(thetaprev) + trans(Znormal)*chol(COV)  );\n    \n    \n    if( thetaprop[0] > Domain(1,0) || thetaprop[0] < Domain(0,0) || thetaprop[1] > Domain(1,1) || thetaprop[1] < Domain(0,1) ){\n      logprob = negativeInf;\t\n      \n    }else{\t\t\t\n      for(int i = 0; i< thnrow; i++){  \n        h1dcross[i] =  fabs(thetaprop[0]-Designmat(i,0));\n        h2dcross[i] =  fabs(thetaprop[1]-Designmat(i,1));\t\n      }\n      mat Sigmacross = sigmasqhat*(1+sqrt(3)*h1dcross/phi1hat)%exp(-sqrt(3)*h1dcross/phi1hat)%(1+sqrt(3)*h2dcross/phi2hat)%exp(-sqrt(3)*h2dcross/phi2hat);\n      vec xpoint = ones(1);\n      xpoint.insert_rows(1,thetaprop);\n      lhXZp = (trans(xpoint)*betahat + trans(Sigmacross)* InvSigma*(y-Xth*betahat))[0]; \n      \n      logprob = lhXZp - lhXZ;             \n    } \n    \n    u = log( randu() );\n    if( u< logprob ){\n      theta.insert_rows(k+1,trans(thetaprop));\n      lhXZ = lhXZp;\t\t\n    }else{\n      theta.insert_rows(k+1,trans(thetaprev));\n    }\n    \n  }\n  \n  return theta;\n}\n\n\n\n// [[Rcpp::export]]\nmat GPmcmcErgmNorm(int Niter, mat theta, mat COV, double lZ, vec betahat, vec phihat, mat Designmat, vec y, vec stat){\n  int thnrow = Designmat.n_rows;                                                \n  int nCOVcols = COV.n_cols;                                                    \n  vec thetaprev(nCOVcols);                                                     \n  \n  double lZp = 0, logprob = 0, u = 0;                                               \n  double negativeInf = -std::numeric_limits<float>::infinity();;\t               \n  double phi1hat = phihat[0], phi2hat = phihat[1], sigmasqhat = phihat[2]; \n  \n  int percentile = 0.0025*thnrow; \n  \n  mat Domain(2,nCOVcols);                                                         \n  for(int i = 0; i < nCOVcols; i++){\n    vec dummy = sort( Designmat.col( i ) );\n    Domain(0,i) = dummy(percentile);\n    Domain(1,i) = dummy(thnrow-1-percentile);\n  }\n  \n  mat h1(thnrow,thnrow), h2(thnrow,thnrow);   \n  vec h1dcross(thnrow), h2dcross(thnrow);     \n  \n  for(int i = 0; i < thnrow; i++){\n    for(int j = 0; j <= i; j++){\n      h1(i,j) = h1(j,i) = fabs(Designmat(i,0)-Designmat(j,0));\n      h2(i,j) = h2(j,i) = fabs(Designmat(i,1)-Designmat(j,1));\n    }\n  }\n  mat Sigma = sigmasqhat*(1+sqrt(3)*h1/phi1hat)%exp(-sqrt(3)*h1/phi1hat)%(1+sqrt(3)*h2/phi2hat)%exp(-sqrt(3)*h2/phi2hat);\n  mat InvSigma = inv(Sigma);\t   \n  mat Xth = ones(thnrow,1);\n  Xth.insert_cols(1,Designmat);\t \n  \n  \n  \n  for(int k = 0; k< Niter; k++){\n    \n    if( (k > 1000) && (k <= 10000) ){ \n      COV = cov(theta);\n    }\t\n    vec Znormal = randn(nCOVcols);\n    for(int i = 0; i< nCOVcols; i++){\n      thetaprev[i] = theta(k,i);\n    }\n    \n    \n    vec thetaprop = trans(  trans(thetaprev) + trans(Znormal)*chol(COV)  );\n    \n    \n    if( thetaprop[0] > Domain(1,0) || thetaprop[0] < Domain(0,0) || thetaprop[1] > Domain(1,1) || thetaprop[1] < Domain(0,1) ){\n      logprob = negativeInf;\t\n      \n    }else{\t\t\t\n      for(int i = 0; i< thnrow; i++){  \n        h1dcross[i] =  fabs(thetaprop[0]-Designmat(i,0));\n        h2dcross[i] =  fabs(thetaprop[1]-Designmat(i,1));\t\n      }\n      mat Sigmacross = sigmasqhat*(1+sqrt(3)*h1dcross/phi1hat)%exp(-sqrt(3)*h1dcross/phi1hat)%(1+sqrt(3)*h2dcross/phi2hat)%exp(-sqrt(3)*h2dcross/phi2hat);\n      vec xpoint = ones(1);\n      xpoint.insert_rows(1,thetaprop);\n      lZp = (trans(xpoint)*betahat + trans(Sigmacross)* InvSigma*(y-Xth*betahat))[0]; \n      \n      logprob = (trans(thetaprop - thetaprev)*stat + (lZ - lZp))[0];\n    } \n    \n    u = log( randu() );\n    if( u< logprob ){\n      theta.insert_rows(k+1,trans(thetaprop));\n      lZ = lZp;\t\t\n    }else{\n      theta.insert_rows(k+1,trans(thetaprev));\n    }\n    \n  }\n  \n  return theta;\n}\n\n\n\n// // [[Rcpp::export]]\n// mat statGibb(mat X, vec coef, int cycle){\n//   int nrow = X.n_rows,indi,indj,prei,prej,res;\n//   double decay = 0.25;\n//   vec star = sum(X,1), changestat = zeros(2), Sumstat = Summary(X) ;\n//   rowvec ivec = trans( zeros(nrow) ), jvec = trans( zeros(nrow) );\n//   vec geoweight = zeros(nrow);\n//   for(int i =0; i<nrow; i++){ geoweight(i) = 1- pow( (1-exp(-decay)),i+1); }\n//   mat Ystats(cycle, 2);\n//   \n//   for(int l = 0; l< cycle; l++){\n//     for(int i = 1; i< nrow; i++){\n//       for(int j = 0; j< i; j++){\n//         ivec(i) = 1; jvec(j) = 1;\n//         res = 0; \n//         \n//         \n//         if(X(i,j)==0){  \n//           indi = star(i) + 1, indj = star(j) + 1; \n//           \n//           changestat(0) = ( Choose(indi,1) + Choose(indj,1) - Choose(star(i),1) - Choose(star(j),1) )/2;\n//           //changestat(0) = 1; \n//           \n//           \n//           changestat(1) = 0;     \n//           for(int k = 0; k< nrow; k++){\n//             if(   ( X(i,k) == 1 ) & ( X(j,k) == 1  )   ){\n//               prei = sum( X.row(i)%X.row(k) );\n//               prej = sum( X.row(j)%X.row(k) );\n//               \n//               changestat(1) = changestat(1) + exp(decay)*geoweight(prei+1-1) ; \n//               if(prei >0){ changestat(1) = changestat(1) - exp(decay)*geoweight(prei-1);} \n//               changestat(1) = changestat(1) + exp(decay)*geoweight(prej+1-1) ; \n//               if(prej >0){ changestat(1) = changestat(1) - exp(decay)*geoweight(prej-1);} \n//               res = res + 1; \n//             }\n//           }\n//           if(res > 0){ changestat(1) = changestat(1) + exp(decay)*geoweight(res-1); }\n//           \n//           \n//           vec r =  exp(trans(coef)*changestat) ;         \n//           double p = r(0)/(1+r(0));   \t\t   \n//           if( randu() < p  ){\n//             X(i,j) = X(j,i) = 1; \n//             star(i) = indi; star(j) = indj;\t\t \n//             Sumstat = Sumstat + changestat;\n//           }\n//           \n//           \n//         }else{\n//           indi = star(i) - 1, indj = star(j) - 1;\t\n//           \n//           changestat(0) = ( Choose(star(i),1) + Choose(star(j),1) - Choose(indi,1) - Choose(indj,1) )/2;\n//           \n//           \n//           changestat(1) = 0;\n//           for(int k = 0; k< nrow; k++){\n//             if(   ( X(i,k) == 1 ) & ( X(j,k) == 1  )   ){\n//               prei = sum( X.row(i)%X.row(k) );\n//               prej = sum( X.row(j)%X.row(k) );\n//               if(prei-1 >0){changestat(1) = changestat(1) - exp(decay)*geoweight(prei-1-1); } \n//               changestat(1) = changestat(1) + exp(decay)*geoweight(prei-1); \n//               if(prej-1 >0){changestat(1) = changestat(1) - exp(decay)*geoweight(prej-1-1); } \n//               changestat(1) = changestat(1) + exp(decay)*geoweight(prej-1); \n//               res = res + 1; \n//             }\n//           }\n//           if(res > 0){ changestat(1) = changestat(1) + exp(decay)*geoweight(res-1); }\n//           \n//           \n//           vec r =  exp(trans(coef)*changestat) ;         \n//           double p = r(0)/(1+r(0));   \t\t   \n//           if( randu() > p  ){\n//             X(i,j) = X(j,i) = 0; \n//             star(i) = indi; star(j) = indj;  \n//             Sumstat = Sumstat - changestat;\n//           }             \n//         }\n//         \n//         ivec(i) = 0; jvec(j) = 0;\n//       }\n//     }\n//     Ystats(l, 0) = Sumstat[0];\n//     Ystats(l, 1) = Sumstat[1];\n//   }\n//   \n//   return(Ystats); \n// }\n\n\n\n\n\n\n\n// [[Rcpp::export]]\nvec W2(mat th, vec stat, mat auxstat, vec weight, double c, double beta, int i, int k, int num){\n  int p = auxstat.n_cols;\n  double temp, temp2, bthi, bthip, k0, k0thi, k0thip, k0thithip;\n  mat knot = zeros(k,p);\n  \n  for(int ip = i; ip < k; ip++){\n    temp = pow(c, 2);\n    for(int j = 0; j < p; j++){\n      temp += pow(th(i,j) - th(ip,j), 2);\n    }\n    \n    for(int j = 0; j < p; j++){\n      bthi = stat[j] - auxstat(i,j);\n      bthip = stat[j] - auxstat(ip,j);\n      temp2 = th(i,j) - th(ip,j);\n      \n      k0 = pow(temp, beta);\n      k0thi = 2*beta*pow(temp, beta-1)*temp2;\n      k0thip = -k0thi;\n      k0thithip = -2*beta*pow(temp,beta-2)*(2*pow(temp2,2)*(beta-1)+temp);\n      \n      knot(ip,j) = bthi*bthip*k0 + bthi*k0thip + bthip*k0thi + k0thithip;\n    }\n  }\n  \n  vec H = zeros(p);\n  \n  for(int j = 0; j < p; j++){\n    double wsq = pow(weight[i],2)*knot(i,j);\n    if(i < k-1){\n      for(int m = (i+1); m < k; m++){\n        wsq += weight[i]*knot(m,j)*weight[m]*2;\n      }\n    }\n    H[j] = wsq;\n  }\n  \n  return(H);\n}\n\n\n\n\n\n// [[Rcpp::export]]\n// Compute w^2 for each row\nmat pW2(mat th, vec stat, mat auxstat, vec weight, double c, double beta, int k, int num){\n  int p = auxstat.n_cols;\n  mat H(k,p);\n  omp_set_num_threads(num);\n  \n  int i;\n#pragma omp parallel shared(H) private(i)\n{\n#pragma omp for schedule(static)\n  for(i = 0; i < k; i++){\n    vec res = W2(th, stat, auxstat, weight, c, beta, i, k, num);\n    \n    for(int j = 0; j < p; j++){\n      H(i,j) = res[j];\n    }\n  }\n}\nreturn(H);\n}\n\n",
    "created" : 1610398087972.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2333734562",
    "id" : "DB1EC8E2",
    "lastKnownWriteTime" : 1608319298,
    "last_content_update" : 1608319298,
    "path" : "~/work/diagnostics/ergm/magnolia/RcppFtns.cpp",
    "project_path" : "RcppFtns.cpp",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}